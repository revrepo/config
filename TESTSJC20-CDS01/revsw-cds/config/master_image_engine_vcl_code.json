{   
    "description": "Current Master VCL Code",
    "custom_vcl": {
      "recv": "# Workaround for Voonik, rewrite the UAs of apps that send a bad UA\nif (req.http.user-agent ~ \"^(android:\\d+:\\d+|okhttp/[\\d\\.]+|gzip)$\") {\n    set req.http.user-agent = \"Dalvik/2.1.0 (Linux; U; Android 6.0.1; SM-J700F Build/MMB29K) Voonik/\" + req.http.user-agent;\n}\n\nunset req.http.Cookie;\nunset req.http.proxy;\n\n# Saving the request URL in X-Rev-Url header (the header is used during cache purging on NB edge servers)\nset req.http.X-Rev-Url = req.url;\n\n###################################################\n## Setup variables to be used throughout the logic\n###################################################\n\nvar.set_string(\"process_url\", req.url);\nvar.set_int(\"cnamed\", 0);\n\nif (var.get_string(\"process_url\") !~ \"https?://\") {\n    var.set_int(\"cnamed\", 1);\n    var.set_string(\"process_url\", regsub(var.get_string(\"process_url\"), \"^/(.*)$\", \"/http://_/\\1\"));\n}\n\nvar.set_string(\"target_image\", regsub(var.get_string(\"process_url\"), \"^.*?/(https?://.*)\", \"\\1\"));\nvar.set_string(\"unsupported_formats\", \"\");\nvar.set_string(\"new_directives\", \"\");\nvar.set_int(\"fallback_width\", 0);\n\n\n# Compute the directives string, ex: /f_jpg/w_120/h_200/m_cropbox\nvar.set_string(\"directives\", regsub(var.get_string(\"process_url\"), \"^(.*?)/https?://.*\", \"\\1\"));\n\n# Add URL parameter directives\nif (var.get_string(\"process_url\") ~ \"^.*?/https?://.*(?:\\?.*\\&|\\?)imgeng=([^\\&]+).*?\") {\n    var.set_string(\"directives\",\n        var.get_string(\"directives\") + regsub(var.get_string(\"process_url\"), \"^.*?/https?://.*(?:\\?.*\\&|\\?)imgeng=([^\\&]+).*?\", \"/\\1/\")\n    );\n}\n\n###################################################\n## Determine if this request is explicit or automatic\n###################################################\n\n# Start in auto mode\nvar.set_int(\"auto\", 1);\nvar.set_int(\"passthrough\", 0);\n\nif (var.get_string(\"directives\") ~ \"/a_false\") {\n    # Explicitly disabled auto mode\n    var.set_int(\"auto\", 0);\n\n} else if (var.get_string(\"directives\") ~ \"/pass_true\") {\n    # Disabled auto mode\n    var.set_int(\"auto\", 0);\n    # Enable passthrough mode\n    var.set_int(\"passthrough\", 1);\n\n# CHECK req.url, shouldn't it be var.get_string(\"directives\")\n# FIX w_auto,100 goes always to the auto 0 mode , so never used,\n# there might be a better fix\n# Width, height or crop was given, use explicit mode\n} else if (req.url ~ \"/(w|h|cr)_[^a-z]\") { // try to disable w_auto,100 match\n    var.set_int(\"auto\", 0);\n}\n\n###################################################\n## Determine DPI Class\n###################################################\n# Default to the lowest DPI class\nvar.set_int(\"dpi_class\", 1);\nvar.set_int(\"res_width\", std.integer(wurfl.get_capability(\"resolution_width\"), 0));\nvar.set_int(\"res_height\", std.integer(wurfl.get_capability(\"resolution_height\"), 0));\nvar.set_int(\"phy_width\", std.integer(wurfl.get_capability(\"physical_screen_width\"), 0));\nvar.set_int(\"phy_height\", std.integer(wurfl.get_capability(\"physical_screen_height\"), 0));\n\nif (var.get_int(\"res_width\") == 0 ||\n    var.get_int(\"res_height\") == 0 ||\n    var.get_int(\"phy_width\") == 0 ||\n    var.get_int(\"phy_height\") == 0 ||\n    wurfl.get_device_id() ~ \"generic\") {\n\n    # DPI is unavalable, use lowest DPI class\n    var.set_int(\"dpi_class\", 1);\n} else if (wurfl.get_capability(\"is_wireless_device\") != \"true\") {\n    # This is not a mobile device, use lowest DPI class\n    var.set_int(\"dpi_class\", 1);\n} else {\n    # Compute the actual DPI and its corresponding class\n    # Note that we're using 254 and 20 instead of 25.4 and 2.0 to avoid decimal math\n    var.set_int(\"dpi\", ( (var.get_int(\"res_width\") / var.get_int(\"phy_width\")) + (var.get_int(\"res_height\") / var.get_int(\"phy_height\")) ) * 254 / 20);\n\n    if (var.get_int(\"dpi\") >= 390) {\n        var.set_int(\"dpi_class\", 4);\n    } else if (var.get_int(\"dpi\") >= 300) {\n        var.set_int(\"dpi_class\", 3);\n    } else if (var.get_int(\"dpi\") >= 230) {\n        var.set_int(\"dpi_class\", 2);\n    } else {\n        var.set_int(\"dpi_class\", 1);\n    }\n}\n\n# IF we have DPR we are going to recalculate dpi_class according to that value\nif (req.http.dpr) {\n\n    var.set_real(\"dpr_real\", std.real(req.http.dpr, 0.0));\n\n    if (var.get_real(\"dpr_real\") >= 3.5) {\n        var.set_int(\"dpi_class\", 4);\n    } else if (var.get_real(\"dpr_real\") >= 2.5) {\n        var.set_int(\"dpi_class\", 3);\n    } else if (var.get_real(\"dpr_real\") >= 1.5) {\n        var.set_int(\"dpi_class\", 2);\n    } else if (var.get_real(\"dpr_real\") > 0.0) {\n        var.set_int(\"dpi_class\", 1);\n    }\n\n}\n\n###################################################\n## Determine unsupported image formats\n###################################################\n\nif (req.http.accept ~ \"image/webp\") {\n    # webp is supported, so we don't include it in the blacklist\n} else {\n    var.set_string(\"unsupported_formats\", var.get_string(\"unsupported_formats\") + \"_webp\");\n}\n\nif (req.http.accept ~ \"image/(vnd\\.ms-photo|jxr)\" || wurfl.get_capability(\"jpeg_xr\") == \"true\") {\n    # JPEG XR is supported, so we don't include it in the blacklist\n} else {\n    var.set_string(\"unsupported_formats\", var.get_string(\"unsupported_formats\") + \"_jxr\");\n}\n\n# We turn off  the automatic conversion of jpg to jp2 , since it produces big files\n# var.set_string(\"unsupported_formats\", var.get_string(\"unsupported_formats\") + \"_jp2\");\n\n# Clients that support JPEG 2000 do not advertise this capability in my testing,\n#  so we are dependent on WURFL for this detection.\nif (req.http.accept ~ \"image/jp2\" || wurfl.get_capability(\"jpeg_2000\") == \"true\") {\n    # JPEG 2000 is supported, so we don't include it in the blacklist\n} else {\n    var.set_string(\"unsupported_formats\", var.get_string(\"unsupported_formats\") + \"_jp2\");\n}\n\n\n###################################################\n## Take different actions based on explicit or automatic or client-hints\n###################################################\n\nif (var.get_int(\"auto\") == 0) {\n    # In explicit mode, all directives are passed to the backend server\n    var.set_string(\"new_directives\", var.get_string(\"directives\"));\n} else {\n    ### Auto Mode\n    ## Determine fallback_width, if specified\n    if (var.get_string(\"directives\") ~ \"/w_auto,\\d+\") {\n        var.set_int(\"fallback_width\", std.integer(regsub(var.get_string(\"directives\"), \"^.*/w_auto,(\\d+)\\b.*$\", \"\\1\"), 0));\n        var.set_string(\"directives\", regsuball(var.get_string(\"directives\"), \"/w_auto,\\d+\", \"\"));\n    }\n\n    ## Determine new image width\n    # Validate if we have client hints\n    var.set_real(\"ch_dpr\", 0.0);\n    var.set_real(\"ch_width\", 0.0);\n    var.set_real(\"ch_viewport_width\", 0.0);\n\n    if (req.http.dpr) {\n        var.set_real(\"ch_dpr\", std.real(req.http.dpr, 0.0));\n    }\n    if (req.http.width ~ \"^\\d+$\") {\n        var.set_real(\"ch_width\", std.real(req.http.width, 0.0));\n    }\n    if (req.http.viewport-width ~ \"^\\d+$\") {\n        var.set_real(\"ch_viewport_width\", std.real(req.http.viewport-width, 0.0));\n    }\n\n    if (var.get_real(\"ch_dpr\") > 0.0 && var.get_real(\"ch_width\") > 0.0) {\n\n        # Use client hints to determine width\n        var.set_string(\"new_width\", req.http.width);\n\n    } else if (var.get_real(\"ch_dpr\") > 0.0 && var.get_real(\"ch_viewport_width\") > 0.0 && wurfl.get_capability(\"is_wireless_device\") == \"true\") {\n\n        var.set_int(\"ch_dpr_1000x\", std.integer(regsub(regsub(var.get_real(\"ch_dpr\"), \"^(\\d+)?\\.(\\d+)?$\", \"\\1\\2\"), \"^0*(\\d*)$\", \"\\1\") , 1000));\n        var.set_int(\"ch_viewport_width_1000x\", std.integer(regsub(regsub(var.get_real(\"ch_viewport_width\"), \"^(\\d+)?\\.(\\d+)?$\", \"\\1\\2\"), \"^0*(\\d*)$\", \"\\1\") , 1000));\n\n        var.set_string(\"new_width\", regsub(\"\" + (var.get_int(\"ch_viewport_width_1000x\") * var.get_int(\"ch_dpr_1000x\")), \"^(\\d+)(\\d{6})$\", \"\\1\"));\n        # NOTE: we do *not* set the Content-DPR here because we cannot know if the image is undersized\n\n    } else if (wurfl.get_capability(\"is_wireless_device\") == \"true\") {\n\n        if (wurfl.get_capability(\"is_tablet\") == \"true\") {\n            # For tablets we use resolution_height because they are normally used in LANDSCAPE orientation\n            if (wurfl.get_device_id() ~ \"generic\") {\n                # This device was detected generically, default to 1280 px wide\n                var.set_string(\"new_width\", \"1280\");\n            } else if (std.integer(wurfl.get_capability(\"resolution_width\"), 1280) > std.integer(wurfl.get_capability(\"resolution_height\"), 0)) {\n                # This is modeled in landscape orientation - it's wider than it is tall\n                var.set_string(\"new_width\", wurfl.get_capability(\"resolution_width\"));\n            } else {\n                # This is modeled in portrait orientation - it's taller than it is wide\n                var.set_string(\"new_width\", wurfl.get_capability(\"resolution_height\"));\n            }\n\n        } else {\n            # For everything else we use resolution_width because they are in PORTRAIT orientation\n            if (wurfl.get_device_id() ~ \"generic\") {\n                # This device was detected generically, default to 720 px wide\n                var.set_string(\"new_width\", \"720\");\n            } else {\n                var.set_string(\"new_width\", wurfl.get_capability(\"resolution_width\"));\n            }\n        }\n\n    } else {\n\n        if (var.get_int(\"fallback_width\") > 0) {\n            # Use the fallback_width if it was specified in /w_auto,<width>\n            var.set_string(\"new_width\", \"\" + var.get_int(\"fallback_width\"));\n        } else {\n            # Non-mobile, use hard-coded maximum\n            var.set_string(\"new_width\", \"2560\");\n        }\n\n    }\n\n    if (var.get_string(\"directives\") ~ \"/pc_[^/]+\") {\n        # Calculate the new width like this: new_width = (percent / 100) * new_width\n        # Note that floating point math is tricky in VCL, so to keep things integral, we do new_width = new_width * percent / 100\n        var.set_int(\"new_width\", std.integer(regsub(var.get_string(\"directives\"), \"^.*?/pc_([^/]+).*$\", \"\\1\"), 0) * std.integer(var.get_string(\"new_width\"), 0) / 100);\n        var.set_string(\"new_directives\", var.get_string(\"new_directives\") + \"/w_\" + var.get_int(\"new_width\"));\n    } else {\n        var.set_string(\"new_directives\", var.get_string(\"new_directives\") + \"/w_\" + var.get_string(\"new_width\"));\n    }\n\n    # `/a_*` and `/pc_*` should never make it back to the origin server\n    # w|h|m are computed in auto mode, so the should not be passed here\n    var.set_string(\"directives\", regsuball(var.get_string(\"directives\"), \"/(?:a|pc|w|h|m)_[^/]+\", \"\"));\n\n    # Pass through the original (sanitized) directives\n    var.set_string(\"new_directives\", var.get_string(\"new_directives\") + var.get_string(\"directives\"));\n}\n\n###################################################\n## Handle unsupported image formats\n###################################################\nif (var.get_string(\"unsupported_formats\") != \"\") {\n    # Each unsupported format is added with \"_\" prepended, so this might look like \"_webp_bmp_gif\"\n    # then we prepend \"/naf\" to it to make \"/naf_webp_bmp_gif\" and add that to the directives\n    var.set_string(\"new_directives\", var.get_string(\"new_directives\") + \"/naf\" + var.get_string(\"unsupported_formats\"));\n}\n\n###################################################\n## Add DPI class\n###################################################\nif (var.get_int(\"dpi_class\") > 0) {\n    var.set_string(\"new_directives\", var.get_string(\"new_directives\") + \"/dpicl_\" + var.get_int(\"dpi_class\"));\n}\n\n###################################################\n## Handle Save-Data client hint\n###################################################\nif (req.http.save-data ~ \"on\") {\n\n    # If compression was already specified, alter it, otherwise add it to the directives\n    if (var.get_string(\"new_directives\") ~ \"/cmpr_\\d+\") {\n        var.set_string(\"new_directives\", regsub(var.get_string(\"new_directives\"), \"/cmpr_\\d+\", \"/cmpr_80\"));\n    } else {\n        var.set_string(\"new_directives\", var.get_string(\"new_directives\") + \"/cmpr_80\");\n    }\n}\n\n# Remove excess \"/\" chars that may have been added above\nvar.set_string(\"new_directives\",\n    regsuball(var.get_string(\"new_directives\"), \"//+\", \"/\")\n);\n\nif (var.get_int(\"passthrough\") == 1) {\n    var.set_string(\"new_directives\", \"/pass_true\");\n}",
      "hit": "#",
      "miss": "# Set the ImageEngine Protocol version for this file\nset req.http.x-ie-proto = \"1.001\";\n\n# For cache misses we need to prefix the request URL to include the\n# origin URL (with hard-coded \"http://\" prefix so even if end user is\n# requesting HTTPS object ImageEngine secondary cache will use HTTP\n# protocol for origin access)\nif (req.url !~ \"^/https?:/\") {\n\n    ###################################################\n    ## Pass naf operator from nuubit to ie\n    ###################################################\n    if (var.get_string(\"unsupported_formats\") != \"\") {\n        # Each unsupported format is added with \"_\" prepended, so this might look like \"_webp_bmp_gif\"\n        # then we prepend \"/naf\" to it to make \"/naf_webp_bmp_gif\" and add that to the directives\n        set req.url = \"/naf\"+var.get_string(\"unsupported_formats\")+\"/http://\" + req.http.x-ie-origin + req.url;\n    } else {\n        set req.url = \"/http://\" + req.http.x-ie-origin + req.url;\n    }\n\n}\n\n# Check whether the IE debug header is set in the request if it is then\n# set an internal flag in the request header so we will know whether\n# we need to delete debug header from the response.\nif (req.http.X-WIT-Debug ~ \"true\") {\n  set req.http.X-WIT-Debug-Save = \"true\";\n} else {\n  set req.http.X-WIT-Debug = \"true\";\n}",
      "deliver": "# Setting some response debug headers\nset resp.http.X-Rev-Wurfl = var.get_string(\"new_directives\");\nset resp.http.X-WIT-Device-ID = wurfl.get_device_id();\nset resp.http.X-Orig-UA = wurfl.get_original_useragent();\n\n# Restoring Vary header before sending to end user\nif (resp.http.X-Rev-Vary != \"\") {\n   set resp.http.Vary = resp.http.X-Rev-Vary;\n   unset resp.http.X-Rev-Vary;\n}\n\n# NOTE: All outbound headers including Content-DPR are computed by ScientiaMobile and\n# are cached and served from this edge cache.",
      "pass": "#",
      "pipe": "#",
      "hash": "# For caching hash we use object URL path, Host value and detected\n# device capabilities\nhash_data(req.url);\nif (req.http.host) {\n  hash_data(req.http.host);\n} else {\n  hash_data(server.ip);\n}\nhash_data(var.get_string(\"new_directives\"));\nreturn (lookup);",
      "synth": "#",
      "backend_response": "# Saving the origin response Vary header in X-Rev-Vary header\n# and removing it from the response. Late we will restore the header\n# value in our end user response.\nset beresp.http.X-Rev-Vary = beresp.http.Vary;\nunset beresp.http.Vary;\n\n# Remove IE debug headers if the object was not requested with\n# debug header set\nif (bereq.http.X-WIT-Debug-Save != \"true\") {\n  unset beresp.http.x-wit-account-id;\n  unset beresp.http.x-wit-bytes;\n  unset beresp.http.x-wit-libwurfl-ver;\n  unset beresp.http.x-wit-wurfl-ver;\n  unset beresp.http.x-wit-time-process;\n  unset beresp.http.x-wit-time-init;\n  unset beresp.http.x-wit-time-fetch;\n  unset beresp.http.x-wit-proto;\n  unset beresp.http.x-wit-token;\n  unset beresp.http.x-rszr-url;\n  unset beresp.http.x-rszr-token;\n  unset beresp.http.x-rszr-type;\n  unset beresp.http.x-wit-origin-cache;\n\n  # Below headers should go to the nuubit side,\n  # We need preserve them for nuubit statistics to work\n  # So please do not enable below lines\n\n  # unset beresp.http.x-wit-bytes-origin;\n  # unset beresp.http.x-wit-format;\n  # unset beresp.http.x-wit-format-origin;\n  # unset beresp.http.x-wit-res;\n  # unset beresp.http.x-wit-res-origin;\n\n  unset beresp.http.x-wit-device-id;\n  unset beresp.http.x-wit-backend-cache;\n  unset beresp.http.x-wit-old-dpi;\n  unset beresp.http.x-wit-new-dpi;\n  unset beresp.http.x-powered-by;\n  unset beresp.http.x-varnish;\n  unset beresp.http.x-debug;\n  unset beresp.http.x-wit-auto-comresssion;\n  unset beresp.http.x-wit-full-url;\n  # Disable jp2 headers\n  unset beresp.http.x-wit-jp2-reduction;\n  unset beresp.http.x-wit-jpg-size;\n  unset beresp.http.x-wit-jp2-size;\n  unset beresp.http.x-wit-cached-jp2-size;\n  unset beresp.http.x-wit-cached-jpg-size;\n  unset beresp.http.x-wit-jp2-reduction;\n  unset beresp.http.x-wit-jp2-error;\n}\n\n# This keeps the objects longer than the TTL specifies in case we\n# get bombarded with requests when a TTL expires, in which case some\n# of the requests in the queue will get stale cached content\n# while we wait for the new data to be fetched from the backend servers.\nset beresp.grace = 2h;\n\nif (beresp.status >= 400 && beresp.status < 600) {\n     # Cache all strange/error responses for a short period of time\n     unset beresp.http.cache-control;\n     unset beresp.http.pragma;\n     unset beresp.http.expires;\n     set beresp.uncacheable = false;\n     set beresp.ttl = 30s;\n} elseif (beresp.status >= 300 && beresp.status < 400) {\n     # Don't cache redirects\n     unset beresp.http.cache-control;\n     unset beresp.http.pragma;\n     unset beresp.http.expires;\n     set beresp.uncacheable = false;\n     set beresp.ttl = 0s;\n} elseif (beresp.ttl < 1h) {\n     # Cache everything valid for at least 1 hour regardless of\n     # cache control settings\n     unset beresp.http.X-Cache-Debug;\n     unset beresp.http.x-cache-status;\n     unset beresp.http.X-Backend-Key;\n     unset beresp.http.Server;  # gunicorn/0.14.3\n     unset beresp.http.Via;  # 1.1 vegur, 1.1 varnish\n     unset beresp.http.X-Served-By;  # cache-lcy1132-LCY\n     unset beresp.http.X-Cache;  # MISS\n     unset beresp.http.X-Cache-Hits;  # 0\n     unset beresp.http.X-Timer;\n     unset beresp.http.set-cookie;\n     set beresp.uncacheable = false;\n     set beresp.ttl = 1h;\n}\n\n# Return deliver here to avoid the varnish logic that hit-for-passes\n# 0s ttl objects\n#   https://www.varnish-cache.org/trac/browser/bin/varnishd/builtin.vcl?rev=4.0#L154\n\n# Required for NUUBIT edge cache purging to work\nset beresp.http.X-Rev-Host = bereq.http.Host;\nset beresp.http.X-Rev-Url = bereq.http.X-Rev-Url;\n\nreturn (deliver);",
      "backend_error": "#",
      "backend_fetch": "#",
      "enabled": true,
      "backends": []
    }
}
